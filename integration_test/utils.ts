import { expect, test } from 'vitest';
import main from '../src/index.js';
import { Options, OxlintConfig } from '../src/types.js';
import { DefaultReporter } from '../src/reporter.js';

import Ajv from 'ajv';
import type { Ajv as AjvCore } from 'ajv';
import oxlintSchema from 'oxlint/configuration_schema.json' with { type: 'json' };

// Validate that the generated oxlintrc conforms to the oxlint JSON Schema.
// This prevents invalid configurations from being generated by @oxlint/migrate.
const validateOxlintrc = (oxlintrc: OxlintConfig) => {
  // @ts-expect-error ajv is really dumb
  const ajv: AjvCore = new Ajv({ allErrors: true, strict: true });
  // Add a dummy uint32 format to suppress warnings
  ajv.addFormat('uint32', true);

  // Add these keywords - which are added for better VS Code integration - to allow validation to pass.
  ajv.addKeyword({
    keyword: 'allowComments',
    validate: () => true,
  });
  ajv.addKeyword({
    keyword: 'allowTrailingCommas',
    validate: () => true,
  });
  ajv.addKeyword({
    keyword: 'markdownDescription',
    validate: () => true,
  });

  const validate = ajv.compile<OxlintConfig>(oxlintSchema);

  if (!validate(oxlintrc)) {
    const errors = validate.errors
      ?.map((error) => `- ${error.instancePath} ${error.message}`)
      .join('\n');
    throw new Error(`Generated oxlintrc is invalid:\n${errors}`);
  } else {
    return;
  }
};

export const getSnapshotResult = async (
  config: Parameters<typeof main>[0],
  oxlintConfig?: OxlintConfig,
  options?: Pick<Options, 'typeAware' | 'jsPlugins'>
) => {
  const reporter = new DefaultReporter();
  const result = await main(config, oxlintConfig, {
    reporter: reporter,
    merge: oxlintConfig !== undefined,
    ...options,
  });

  // Validate that the generated config conforms to the oxlint schema
  validateOxlintrc(result);

  return {
    config: result,
    warnings: reporter
      .getReports()
      // filter out unsupported rules
      .filter((error) => !error.startsWith('unsupported rule: local/'))
      // .filter((error) => !error.startsWith('unsupported rule: perfectionist/'))
      .filter((error) => !error.startsWith('unsupported rule: toml/'))
      .filter((error) => !error.startsWith('unsupported rule: style/')),
  };
};

export const getSnapShotMergeResult = async (
  config: Parameters<typeof main>[0],
  oxlintConfig: OxlintConfig
) => {
  const result = await getSnapshotResult(config, oxlintConfig);
  const mergedResult = structuredClone(result);
  const result2 = await getSnapshotResult(config, mergedResult.config);

  expect(result2).toStrictEqual(result);

  return result2;
};

export const testProject = (
  project: string,
  projectConfig: Parameters<typeof main>[0]
) => {
  test(`${project}`, async () => {
    const result = await getSnapshotResult(projectConfig);
    expect(result).toMatchSnapshot(project);
  });

  test(`${project} --type-aware`, async () => {
    const result = await getSnapshotResult(projectConfig, undefined, {
      typeAware: true,
    });
    expect(result).toMatchSnapshot(`${project}--type-aware`);
  });

  test(`${project} merge`, async () => {
    const result = await getSnapShotMergeResult(projectConfig, {
      categories: {
        correctness: 'error',
        perf: 'error',
      },
    });
    expect(result).toMatchSnapshot(`${project}--merge`);
  });

  test(`${project} --js-plugins`, async () => {
    const result = await getSnapshotResult(projectConfig, undefined, {
      jsPlugins: true,
    });
    expect(result).toMatchSnapshot(`${project}--js-plugins`);
  });
};
